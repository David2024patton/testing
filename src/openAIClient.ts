/**
 * File: src/openAIClient.ts
 * Location: src/openAIClient.ts
 * Description: Client for interacting with the OpenAI API.
 * Retrieves API key and model settings from configuration, sends prompts,
 * and returns generated text. Supports authentication via API key and model switching.
 * NOTE: If OpenAI API endpoints or auth schemes change, update constructor logic.
 *
 * Purpose:
 * - Client for interacting with the OpenAI API.
 * - Retrieves API key and model settings from configuration.
 * - Sends prompts and returns generated text.
 * - Supports authentication via API key and model switching.
 *
 * API:
 * - `generateCode(prompt: string): Promise<string>` - Generates text/code using the configured model.
 * - `setModel(model: string): void` - Updates the model identifier for subsequent requests.
 * - `setApiKey(key: string): void` - Updates the API key for authentication.
 *
 * Modification Points:
 * - To support additional OpenAI API features, extend the generateCode method.
 * - To handle different response formats, update the response parsing logic.
 */

import * as vscode from 'vscode';
import axios from 'axios';
import { LLMClient } from './AIClients';
import { Logger } from './logger';
import { SettingsManager } from './settingsManager';

export class OpenAIClient implements LLMClient {
  private apiKey: string;
  private model: string;
  private baseUrl: string = 'https://api.openai.com/v1/chat/completions';
  private temperature: number = 0.7;
  private maxTokens: number = 4096;

  constructor(private settings: SettingsManager, private logger: Logger) {
    this.apiKey = settings.getOpenAIKey();
    this.model = settings.getOpenAIModel() || 'gpt-4';
    
    if (!this.apiKey) {
      this.logger.warn('OpenAI API key not set');
    }
  }

  /**
   * Set the OpenAI API key
   * @param key The API key
   */
  public setApiKey(key: string): void {
    this.apiKey = key;
    this.logger.info('OpenAI API key updated');
  }

  /**
   * Set the OpenAI model to use
   * @param model The model identifier (e.g., 'gpt-4', 'gpt-3.5-turbo')
   */
  public setModel(model: string): void {
    this.model = model;
    this.logger.info('OpenAI model updated', { model });
  }

  /**
   * Set performance parameters
   * @param mode Performance mode: 'high', 'balanced', or 'efficient'
   */
  public setPerformanceMode(mode: string): void {
    switch (mode) {
      case 'high':
        this.temperature = 0.8;
        this.maxTokens = 8192;
        break;
      case 'balanced':
        this.temperature = 0.7;
        this.maxTokens = 4096;
        break;
      case 'efficient':
        this.temperature = 0.5;
        this.maxTokens = 2048;
        break;
    }
    this.logger.info('OpenAI performance mode updated', { mode, temperature: this.temperature, maxTokens: this.maxTokens });
  }

  /**
   * Generate code using the OpenAI API
   * @param prompt The prompt to send to the API
   * @param customConfig Optional custom configuration
   * @returns The generated code
   */
  public async generateCode(prompt: string, customConfig?: Record<string, any>): Promise<string> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key not set');
    }

    try {
      // Prepare the system message for code generation
      const systemMessage = `You are an expert programmer. Generate high-quality, well-documented code based on the user's requirements. 
      Focus on best practices, clean code principles, and security. Include appropriate error handling and comments.`;

      // Prepare the request payload
      const payload = {
        model: this.model,
        messages: [
          { role: 'system', content: systemMessage },
          { role: 'user', content: prompt }
        ],
        temperature: customConfig?.temperature ?? this.temperature,
        max_tokens: customConfig?.maxTokens ?? this.maxTokens,
        top_p: 1,
        frequency_penalty: 0,
        presence_penalty: 0
      };

      // Make the API request
      const response = await axios.post(this.baseUrl, payload, {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        }
      });

      // Extract the generated text from the response
      const generatedText = response.data.choices[0]?.message?.content;
      
      if (!generatedText) {
        throw new Error('No content generated by OpenAI');
      }

      // Log success (without the actual content for privacy)
      this.logger.info('OpenAI code generation successful', { 
        model: this.model,
        promptLength: prompt.length,
        responseLength: generatedText.length
      });

      return this.extractCodeFromResponse(generatedText);
    } catch (error: any) {
      // Handle API errors
      if (error.response) {
        const status = error.response.status;
        const data = error.response.data;
        
        this.logger.error('OpenAI API error', { status, error: data });
        
        if (status === 401) {
          throw new Error('Invalid OpenAI API key');
        } else if (status === 429) {
          throw new Error('OpenAI API rate limit exceeded');
        } else {
          throw new Error(`OpenAI API error: ${data.error?.message || 'Unknown error'}`);
        }
      } else {
        this.logger.error('OpenAI request failed', { error: error.message });
        throw new Error(`Failed to generate code: ${error.message}`);
      }
    }
  }

  /**
   * Get available models from OpenAI
   * @returns Array of model names
   */
  public async getAvailableModels(): Promise<string[]> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key not set');
    }

    try {
      const response = await axios.get('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`
        }
      });

      // Filter for chat models
      const chatModels = response.data.data
        .filter((model: any) => 
          model.id.includes('gpt') && 
          !model.id.includes('instruct') && 
          !model.id.includes('-if')
        )
        .map((model: any) => model.id);

      return chatModels;
    } catch (error: any) {
      this.logger.error('Failed to get OpenAI models', { error: error.message });
      return ['gpt-4', 'gpt-3.5-turbo']; // Fallback to common models
    }
  }

  /**
   * Extract code blocks from the response
   * @param response The raw response from OpenAI
   * @returns Cleaned code
   */
  private extractCodeFromResponse(response: string): string {
    // Look for code blocks in markdown format
    const codeBlockRegex = /```(?:python|javascript|java|typescript)?\s*\n([\s\S]*?)```/;
    const match = codeBlockRegex.exec(response);
    
    if (match && match[1]) {
      return match[1].trim();
    }
    
    // If no code block found, return the full response
    return response;
  }
}
